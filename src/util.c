//
// cryptsweeper - fight through the crypt to slay the vampire
// by Sean Connelly (@velipso), https://sean.fun
// Project Home: https://github.com/velipso/cryptsweeper
// SPDX-License-Identifier: 0BSD
//

#include "util.h"

const u8 ctz32_bitpos[32] SECTION_ROM = {
  0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12,
  18, 6, 11, 5, 10, 9
};

// inverse_lut[i] = 65536 / (i + 1)
const u16 inverse16_lut[256] SECTION_ROM = {
  0xffff, 0x8000, 0x5555, 0x4000, 0x3333, 0x2aab, 0x2492, 0x2000, 0x1c72, 0x199a, 0x1746, 0x1555,
  0x13b1, 0x1249, 0x1111, 0x1000, 0x0f0f, 0x0e39, 0x0d79, 0x0ccd, 0x0c31, 0x0ba3, 0x0b21, 0x0aab,
  0x0a3d, 0x09d9, 0x097b, 0x0925, 0x08d4, 0x0889, 0x0842, 0x0800, 0x07c2, 0x0788, 0x0750, 0x071c,
  0x06eb, 0x06bd, 0x0690, 0x0666, 0x063e, 0x0618, 0x05f4, 0x05d1, 0x05b0, 0x0591, 0x0572, 0x0555,
  0x0539, 0x051f, 0x0505, 0x04ec, 0x04d5, 0x04be, 0x04a8, 0x0492, 0x047e, 0x046a, 0x0457, 0x0444,
  0x0432, 0x0421, 0x0410, 0x0400, 0x03f0, 0x03e1, 0x03d2, 0x03c4, 0x03b6, 0x03a8, 0x039b, 0x038e,
  0x0382, 0x0376, 0x036a, 0x035e, 0x0353, 0x0348, 0x033e, 0x0333, 0x0329, 0x031f, 0x0316, 0x030c,
  0x0303, 0x02fa, 0x02f1, 0x02e9, 0x02e0, 0x02d8, 0x02d0, 0x02c8, 0x02c1, 0x02b9, 0x02b2, 0x02ab,
  0x02a4, 0x029d, 0x0296, 0x028f, 0x0289, 0x0283, 0x027c, 0x0276, 0x0270, 0x026a, 0x0264, 0x025f,
  0x0259, 0x0254, 0x024e, 0x0249, 0x0244, 0x023f, 0x023a, 0x0235, 0x0230, 0x022b, 0x0227, 0x0222,
  0x021e, 0x0219, 0x0215, 0x0211, 0x020c, 0x0208, 0x0204, 0x0200, 0x01fc, 0x01f8, 0x01f4, 0x01f0,
  0x01ed, 0x01e9, 0x01e5, 0x01e2, 0x01de, 0x01db, 0x01d7, 0x01d4, 0x01d1, 0x01ce, 0x01ca, 0x01c7,
  0x01c4, 0x01c1, 0x01be, 0x01bb, 0x01b8, 0x01b5, 0x01b2, 0x01af, 0x01ac, 0x01aa, 0x01a7, 0x01a4,
  0x01a1, 0x019f, 0x019c, 0x019a, 0x0197, 0x0195, 0x0192, 0x0190, 0x018d, 0x018b, 0x0188, 0x0186,
  0x0184, 0x0182, 0x017f, 0x017d, 0x017b, 0x0179, 0x0176, 0x0174, 0x0172, 0x0170, 0x016e, 0x016c,
  0x016a, 0x0168, 0x0166, 0x0164, 0x0162, 0x0160, 0x015e, 0x015d, 0x015b, 0x0159, 0x0157, 0x0155,
  0x0154, 0x0152, 0x0150, 0x014e, 0x014d, 0x014b, 0x0149, 0x0148, 0x0146, 0x0144, 0x0143, 0x0141,
  0x0140, 0x013e, 0x013d, 0x013b, 0x013a, 0x0138, 0x0137, 0x0135, 0x0134, 0x0132, 0x0131, 0x012f,
  0x012e, 0x012d, 0x012b, 0x012a, 0x0129, 0x0127, 0x0126, 0x0125, 0x0123, 0x0122, 0x0121, 0x011f,
  0x011e, 0x011d, 0x011c, 0x011a, 0x0119, 0x0118, 0x0117, 0x0116, 0x0115, 0x0113, 0x0112, 0x0111,
  0x0110, 0x010f, 0x010e, 0x010d, 0x010b, 0x010a, 0x0109, 0x0108, 0x0107, 0x0106, 0x0105, 0x0104,
  0x0103, 0x0102, 0x0101, 0x0100
};

static inline u32 whisky2(u32 i0, u32 i1){
  u32 z0 = (i1 * 1833778363) ^ i0;
  u32 z1 = (z0 *  337170863) ^ (z0 >> 13) ^ z0;
  u32 z2 = (z1 *  620363059) ^ (z1 >> 10);
  u32 z3 = (z2 *  232140641) ^ (z2 >> 21);
  return z3;
}

bool random_pick(u32 index, u32 seed) {
  if (index == 0) return true;
  return (whisky2(seed, index) & 0xffff) < inverse16_lut[index > 0xff ? 0xff : index];
}
